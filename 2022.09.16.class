// Definition
// Balanced number is the number that * The sum of all digits to the left of the middle digit(s) and the sum of all digits to the right of the middle digit(s) are equal*.

// Task
// Given a number, Find if it is Balanced or not .

// Warm-up (Highly recommended)
// Playing With Numbers Series
// Notes
// If the number has an odd number of digits then there is only one middle digit, e.g. 92645 has middle digit 6; otherwise, there are two middle digits , e.g. 1301 has middle digits 3 and 0

// The middle digit(s) should not be considered when determining whether a number is balanced or not, e.g 413023 is a balanced number because the left sum and right sum are both 5.

// Number passed is always Positive .

// Return the result as String

// Input >> Output Examples
// (balanced-num 7) ==> return "Balanced"
// Explanation:
// Since , The sum of all digits to the left of the middle digit (0)

// and the sum of all digits to the right of the middle digit (0) are equal , then It's Balanced

// (balanced-num 295591) ==> return "Not Balanced"
// Explanation:
// Since , The sum of all digits to the left of the middle digits (11)

// and the sum of all digits to the right of the middle digits (10) are Not equal , then It's Not Balanced

// Note : The middle digit(s) are 55 .

// (balanced-num 959) ==> return "Balanced"
// Explanation:
// Since , The sum of all digits to the left of the middle digits (9)

// and the sum of all digits to the right of the middle digits (9) are equal , then It's Balanced

// Note : The middle digit is 5 .

// (balanced-num 27102983) ==> return "Not Balanced"
// Explanation:
// Since , The sum of all digits to the left of the middle digits (10)

// and the sum of all digits to the right of the middle digits (20) are Not equal , then It's Not Balanced

// Note : The middle digit(s) are 02 .

// 내 답안
import java.util.Arrays;

public class Solution
{
    public static String balancedNum(long number)
    {
        String numStr = String.valueOf(number);

        boolean res = false;
        if(numStr.length() % 2 == 0){
            String s1 = numStr.substring(0, numStr.length() / 2-1);
            String s2 = numStr.substring( numStr.length() / 2+1);
            if(s1.isEmpty() || s2.isEmpty()) return "Balanced";
            res = Arrays.stream(s1.split("")).mapToInt(Integer::valueOf).sum() ==Arrays.stream(s2.split("")).mapToInt(Integer::valueOf).sum();
        } else {
            String s3 = numStr.substring(0,  numStr.length() / 2);
            String s4 = numStr.substring( numStr.length() / 2+1);
            if(s3.isEmpty() || s4.isEmpty()) return "Balanced";
            res = Arrays.stream(s3.split("")).mapToInt(Integer::valueOf).sum() ==Arrays.stream(s4.split("")).mapToInt(Integer::valueOf).sum();
        }
        return numStr.length() == 1 ? "Balanced" : res ? "Balanced" : "Not Balanced";

    }
}
// 모범답안
import java.util.function.IntUnaryOperator;

public class Solution {
  public static String balancedNum(final long number) {
    return new Solution(number).compute();
  }
  
  private final String str;
  
  private Solution(final long number) {
    str = String.valueOf(number);
  }
  
  private String compute() { return (isSmall() || leftSum() == rightSum()) ? "Balanced" : "Not Balanced"; }
  
  private boolean isSmall()  { return str.length() < 3; }
  private int     leftSum()  { return str.chars().limit((str.length() - 1) / 2    ).map(toDigit).sum(); }
  private int     rightSum() { return str.chars().skip ( str.length()      / 2 + 1).map(toDigit).sum(); }
  
  private static final IntUnaryOperator toDigit = c -> Character.digit(c, 10);
}