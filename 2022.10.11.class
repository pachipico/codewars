// In this kata you have to write a method that folds a given array of integers by the middle x-times.

// An example says more than thousand words:

// Fold 1-times:
// [1,2,3,4,5] -> [6,6,3]

// A little visualization (NOT for the algorithm but for the idea of folding):

//  Step 1         Step 2        Step 3       Step 4       Step5
//                      5/           5|         5\          
//                     4/            4|          4\      
// 1 2 3 4 5      1 2 3/         1 2 3|       1 2 3\       6 6 3
// ----*----      ----*          ----*        ----*        ----*


// Fold 2-times:
// [1,2,3,4,5] -> [9,6]
// As you see, if the count of numbers is odd, the middle number will stay. Otherwise the fold-point is between the middle-numbers, so all numbers would be added in a way.

// The array will always contain numbers and will never be null. The parameter runs will always be a positive integer greater than 0 and says how many runs of folding your method has to do.

// If an array with one element is folded, it stays as the same array.

// The input array should not be modified!

// Have fun coding it and please don't forget to vote and rank this kata! :-)

// I have created other katas. Have a look if you like coding and challenges.


// 내 답안
public class Kata
{
  public static int[] foldArray(int[] array, int runs)
  {
      for(int i = 0; i < runs; i++ ) {
			  array = fold(array);
		  }
    return array;
  }
  
	public static int[] fold(int[] arr) {
		int[] res;
		if (arr.length % 2 == 0) {
			res = new int[arr.length / 2];
			for (int i = 0; i <= arr.length / 2 - 1; i++) {
				res[i] = arr[i] + arr[arr.length - i - 1];
			}
		} else {
			res = new int[(int) Math.ceil(arr.length / 2) + 1];
			for (int i = 0; i <= (int) Math.ceil(arr.length / 2); i++) {
				res[i] = i == (int) Math.ceil(arr.length / 2) ? arr[i] : arr[i] + arr[arr.length - 1 - i];
			}
		}
		return res;
	}
}

// 모범 답안
import java.util.Arrays;
import java.util.stream.IntStream;


public class Kata {

  public static int[] foldArray(int[] array, int runs) {
    final int[] result = Arrays.copyOfRange(array, 0, Math.round(array.length / 2.0f));
    
    IntStream.range(0, array.length / 2)
             .forEach(i -> result[i] = array[i] + array[array.length - 1 - i]);
        
    return runs > 1 ? foldArray(result, --runs) : result;
  }

}