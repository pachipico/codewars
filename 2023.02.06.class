//Background information
//        The Hamming Code is used to correct errors, so-called bit flips, in data transmissions. Later in the description follows a detailed explanation of how it works.
//        In this Kata we will implement the Hamming Code with bit length 3; this has some advantages and disadvantages:
//
//        [ + ] It's simple to implement
//        [ + ] Compared to other versions of hamming code, we can correct more mistakes
//        [ - ] The size of the input triples
//        Task 1: Encode function
//        Implement the encode function, using the following steps:
//
//        convert every letter of the text to its ASCII value; (ASCII value of space is 32)
//        convert ASCII values to 8-bit binary;
//        triple every bit;
//        concatenate the result;
//        For example:
//
//        input: "hey"
//        --> 104, 101, 121                  // ASCII values
//        --> 01101000, 01100101, 01111001   // binary
//        --> 000111111000111000000000 000111111000000111000111 000111111111111000000111  // tripled
//        --> "000111111000111000000000000111111000000111000111000111111111111000000111"  // concatenated
//        Task 2: Decode function:
//        Check if any errors happened and correct them. Errors will be only bit flips, and not a loss of bits:
//
//        111 --> 101 : this can and will happen
//        111 --> 11 : this cannot happen
//        Note: the length of the input string is also always divisible by 24 so that you can convert it to an ASCII value.
//
//        Steps:
//
//        Split the input into groups of three characters;
//        Check if an error occurred: replace each group with the character that occurs most often, e.g. 010 --> 0, 110 --> 1, etc;
//        Take each group of 8 characters and convert that binary number;
//        Convert the binary values to decimal (ASCII);
//        Convert the ASCII values to characters and concatenate the result
//        For example:
//
//        input: "100111111000111001000010000111111000000111001111000111110110111000010111"
//        --> 100, 111, 111, 000, 111, 001, ...  // triples
//        -->  0,   1,   1,   0,   1,   0,  ...  // corrected bits
//        --> 01101000, 01100101, 01111001       // bytes
//        --> 104, 101, 121                      // ASCII values
//        --> "hey"

// 내 답안
import java.util.stream.Collectors;
import java.util.Arrays;

public class CodeWars {
    public String encode(String text) {
        return text.chars().asDoubleStream().mapToObj(v -> Arrays.stream(toBinStr((int)v).split("")).map(st -> st.repeat(3)).collect(Collectors.joining())).collect(Collectors.joining());
    }
    public String decode(String bits) {
        return Arrays.stream(Arrays.stream(bits.split("(?<=\\G.{3})")).map(v -> less(v)).collect(Collectors.joining()).split("(?<=\\G.{8})")).map(bt -> (char) Integer.parseInt(bt, 2)).map(String::valueOf).collect(Collectors.joining());
    }

    private static String toBinStr(int i){
        String res = Integer.toBinaryString(i);
        return "0".repeat(8-res.length()) + res;
    }

    private static String less (String st){
        int one = 0;
        int zero = 0;
        for(String s : st.split("")){
            if(s.equals("0")) zero++;
            else one++;
        }
        return one > zero ? "1" : "0";
    }
}

// 모범답안
import static java.util.stream.Collectors.joining;
        import static java.util.stream.Stream.of;

class CodeWars {
    String encode(String text) {
        return text.chars().mapToObj(Integer::toBinaryString)
                .map(s -> ("0".repeat(8 - s.length()) + s).replaceAll(".", "$0$0$0")).collect(joining());
    }

    String decode(String bits) {
        bits = of(bits.split("(?<=\\G.{3})")).map(s -> s.indexOf('0') != s.lastIndexOf('0') ? "0" : "1").collect(joining());
        return of(bits.split("(?<=\\G.{8})")).map(i -> (char) Integer.parseInt(i, 2) + "").collect(joining());
    }
}